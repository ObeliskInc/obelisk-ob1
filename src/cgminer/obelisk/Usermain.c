/**
 * \file Usermain.c
 *
 * \brief User Main
 * \date STARTED: 3/19/2018
 *
 * \mainpage Obelisk Test Hash Board SPI - Documentation Notes
 *
 * \section Legal
 * **Copyright Notice:**
 * Copyright (c) 2018 All rights reserved.
 *
 * **Proprietary Notice:**
 *       This document contains proprietary information and neither the document
 *       nor said proprietary information shall be published, reproduced, copied,
 *       disclosed or used for any purpose other than the consideration of this
 *       document without the expressed written permission of a duly authorized
 *       representative of said Company.
 *
 * **Disclaimer Notice:**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING,
 * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ENGINEERING OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * \section Purpose
 * Written for the SAMG55XP board to provide a means of exercising hash boards until the real controller
 * board hardware is functioning.
 *
 * Primary function is to support testing the hardware devices and the AC coupled SPI interface to the
 * CSS Blake2B ASIC. To do this we service various tasks including:
 * -# Accept simple character input from console and perform tasks
 * -# Transmit/receive data on a SPI bus interface
 *
 * \section Description
 * Basic software structure is a main loop that continuously runs and executes tasks. Occasionally
 * interrupts occur that either set signal flags to run the tasks from the main loop or perform
 * tasks on their own (if they are short).
 *
 * The ATSAMG55XP is being used for testing and is not expected to be the system processor.
 * Therefore, firmware development and documentation may be casually implemented in interests of speed of development.
 *
 * Processor peripheral usage summary (use Atmel START utility for details):
 * WHEN USING ATSAMG55 XPlained EVAL BOARD:
 * - FLEXCOM 5 as SPI: on XPlained connects to EXT1 and 3; EXT3 used for test interface.
 * - FLEXCOM 4 as I2C: on XPlained connects to EXT3
 * - FLEXCOM 7 as UART: used for debug console (embedded debug port)
 * - TC0: 1KHz system timer for sub-timer generation.
 *
 * \section Requirements
 * **Expected target devices:**
 * - Processor is Microchip SAMA5D27; chosen for Linux support and low cost
 *
 * \section Usage under development
 * Initial development done with SAMG55XP evaluation board.
 *
 * - Initial test processor is Atmel/Microchip ATSAMG55; chosen for convenience
 * **Development environment:**
 * ATSAMG55 under AS7 (build 7.0.1417)
 * TechEn (TAR) project initially constructed using Atmel ASF4/START (start.atmel.com) for the ATSAMG55 XPlained board (SAMG55XP).
 * Sadly, this build of AS7 has a number of problems.
 * - It sometimes (often?) deletes the ApplicationFiles folder and the Device_Startup folder when reconfiguring the project.
 *   Workaround for this is to remove these folders from the project prior to reconfiguring and then including them back.
 * - Above two issues have been logged to Microchip for fix in future versions.
 * - Autogenerated code gives duplicate IRQ handlers for Flexcom peripherals. TWI, SPI and UART files need to be edited and ensure
 *   that only the relevant IRQ handler functions are enabled.
 * -- In hpl_twi.c, find and comment out FLEXCOM5_Handler() and FLEXCOM7_Handler().
 * -- In hpl_usartc, find and comment out FLEXCOM4_Handler() and FLEXCOM5_Handler().
 * -- In hpl_spi.c, find and comment out FLEXCOM4_Handler() and FLEXCOM7_Handler().
 * - Autogenerated code in hpl_twi.c has bug in the I2C transfer function name _i2c_m_async_transfer().  Proper code is duplicated in
 * TWI_Support.c as compiled out code.  Cut and paste this into hpl_twi.c. Support case is logged with Microchip to fix this issue.
 *
 * -# Use AtmelStudio to open project.
 * -# Build the program and download it inside the evaluation board.
 * -# On the computer, open and configure a terminal application
 *    (e.g. RealTerm, TeraTerm, Putty, etc.) with these settings:
 *   - 115200 bauds
 *   - 8 bits of data
 *   - No parity
 *   - 1 stop bit
 *   - No flow control
 * -# Start the application.
 * -# The LED(s) should start blinking on the evaluation board.
 * -# When compiled with keyword DEBUG_CONSOLE defined (in Console.h), it should send ASCII text strings to the
 *    UART for test purposes.  In the terminal window, a brief start up message should appear.
 *
 * \section Main History
 * PRERELEASE/DEVELOPMENT*
 * - 20180319 Rev 0.01 Started; using AS7 (build 7.0.1417); Running on ATSAMG55 XP eval board
 * - 20180702 Rev 0.-- Porting into SAMA5D27 SOM
 *
 * \section BUILD NOTES
 * Platform is controlled by complile switches located in usermain.h.
 * - Devel operation HARDWARE_PLATFORM ==  HW_ATSAMG55_XP_BOARD; runs on the SAMG55 evaluation board
 * - Normal operation HARDWARE_PLATFORM ==  HW_SAMA5D27_SOM; runs on the expected system
 *
 * \section Known Issues
 *  - See #TODO items throughout the code.
 *  - See defined DEBUG_CONSOLE in Console.h; set to true to enable output to a uart console (serial port) for debug purposes.
 *
 * \section "Style Summary"
 *  Comments with keywords are noted for use of Doxygen mainpage.
 *  - using  Hungarian systems notation but shouldn't overdo it;
 *       - vars are prefixed by type;
 *          - b - bool, ui - unsigned int, l - long, z - zero terminate string,
 *            s - struct, h - handle, x - index, etc
 *      - arrays add 'a' after prefix; e.g. ba prefix is bool array, ca is char array, sa is struct array, ...
 *      - ptrs are prefixed by 'p'; e.g. pz is a ptr to zero-terminated string
 *      - functions are prefixed by return type
 *          - use cb_ prefix for callbacks
 *          - use isr_ prefix for simple interrupt service
 *          - use io_ for io descriptors (typically a structure)
 *      - global scope variables (strongly discouraged!) should begin with g_ prefix
 * - using CamelCase for var and function names for custom application code.
 *      - where abbreviations and mnemonics are used, put an '_' to separate for readability as needed.
 *      - where function and variable names are defined by the vendor tools; leave them as is
 *
 */

/***   INCLUDE FILES               ***/

//#if (HW_ATSAMG55_XP_BOARD != HARDWARE_PLATFORM)
// Initialization/declarations for SAMA5D27

// General or std-c files
#include <unistd.h>

// Project specific include files
#include "Usermain.h"
#include "spi.h"
#include "SPI_Support.h"
#include "TWI_Support.h"
#include "Ob1Hashboard.h"
#include "gpio_bsp.h"
#include "MCP9903_hal.h"
#include "MiscSupport.h"
#include "MCP23S17_hal.h"
#include "CSS_SC1_hal.h"
#include "CSS_DCR1_hal.h"
#include "Console.h"
#include "ads1015.h"
#include "EMCTest.h"
#include "Ob1Utils.h"

//=================================================================================================
// CONTROL LOOP CONFIG/VARS
//
char outBuf[1024];

// CONTROL LOOP CONFIG
#define CONTROL_LOOP_SUPER_HIGH_TEMP 122
#define CONTROL_LOOP_HIGH_TEMP 120
#define CONTROL_LOOP_LOW_TEMP 110

#define MIN_BIAS -5
#define NO_BIAS 0
#define MAX_BIAS 5

// Start at /4, MAX_BIAS
// If over HIGH_TEMP, drop by one bias unit each tenth of a second
// If under LOW_TEMP, increment by one bias unit
// Add visible printouts showing the current voltage and bias
// /4+1
// Add code to wrap around the bias: decrementBias(ControlLoopState),
// increment_bias(ControlLoopState)

ControlLoopState controlLoopState[MAX_NUMBER_OF_HASH_BOARDS] = {
    { 0, 0, 0, 2, NO_BIAS, 0, true },
    { 1, 0, 0, 2, NO_BIAS, 0, true },
    { 2, 0, 0, 2, NO_BIAS, 0, true },
};

// // Functions for adding/subtracting bias and dividers
// void incrementDivider(ControlLoopState* clState)
// {
//     switch (clState->currDivider) {
//     case 1:
//     case 2:
//     case 4:
//         clState->currDivider *= 2;
//         break;
//     default:
//         // 8 or any other value means no change
//         break;
//     }
//     clState->lastChangeUp = true;
// }

// void decrementDivider(ControlLoopState* clState)
// {
//     switch (clState->currDivider) {
//     case 2:
//     case 4:
//     case 8:
//         clState->currDivider /= 2;
//         break;
//     default:
//         // 1 or any other value means no change
//         break;
//     }
//     clState->lastChangeUp = false;
// }

// void incrementBias(ControlLoopState* clState)
// {
//     if (clState->currBias == MAX_BIAS) {
//         int currDivider = clState->currDivider;
//         decrementDivider(clState);
//         // Prevent overflow
//         if (currDivider > 1) {
//             clState->currBias = MIN_BIAS;
//         }
//     } else {
//         clState->currBias += 1;
//     }
//     clState->lastChangeUp = true;
// }

// void decrementBias(ControlLoopState* clState)
// {
//     if (clState->currBias == MIN_BIAS) {
//         int currentDivider = clState->currDivider;
//         incrementDivider(clState);
//         // Prevent underflow of the bias
//         if (currentDivider < 8) {
//             clState->currBias = MAX_BIAS;
//         }
//     } else {
//         clState->currBias -= 1;
//     }
//     clState->lastChangeUp = false;
// }

// void formatControlLoopState(char* buffer, ControlLoopState* clState)
// {
//     (void)sprintf(buffer, "HB%u: %uC %c /%u%s%d bias",
//         clState->boardId + 1,
//         clState->lastTemp,
//         clState->lastChangeUp ? '^' : 'v',
//         clState->currDivider,
//         clState->currBias < 0 ? "" : "+",
//         clState->currBias);
// }

// void formatDividerAndBias(char* buffer, ControlLoopState* clState)
// {
//     (void)sprintf(buffer, "/%u%s%d",
//         clState->currDivider,
//         clState->currBias < 0 ? "" : "+",
//         clState->currBias);
// }

//=================================================================================================

//   LOCAL DEFINITIONS
#define STARTUP_TIMERS_MSG (MSG_TKN_INFO "System timers init: ")
#define MAX_HASH_ASIC_TEMPERATURE 125 // should be 90 in deg C; asic temperature we can tolerate

//   LOCAL FUNCTION PROTOTYPES
#ifdef ENABLE_EMC_TEST_FUNCTIONS
//static void SetEMCTest(void);
#endif // #ifdef ENABLE_EMC_TEST_FUNCTIONS

//#else
/*
    // Initialization/declarations for ATSAMG55
    
    // #include "hal_spi_m_async.h"
    #include "ApplicationFiles\Usermain.h"
    #include "ApplicationFiles\Support\Jiffies\SysTickJiffies.h" // system tick support
    #include "ApplicationFiles\Support\Console\Console.h"        // development console/uart support
    #include "ApplicationFiles\BSP\MCP9903\MCP9903_hal.h"
    #include "ApplicationFiles\BSP\SPI_Support\SPI_Support.h"
    #include "ApplicationFiles\BSP\TWI_Support\TWI_Support.h"
    #include "ApplicationFiles\BSP\HashBoard\Ob1Hashboard.h"
    #include "ApplicationFiles\BSP\SC1ASIC\CSS_SC1_hal.h"
    #include "ApplicationFiles\BSP\MCP23S17\MCP23S17_hal.h"
    //  LOCAL FUNCTION PROTOTYPES
    static void cb_TIMER_TC0_task1(const struct timer_task *const timer_task);
    static void cb_TIMER_TC0_task2(const struct timer_task *const timer_task);
    static void StartupTimerTasks(void);
    
    //   LOCAL DATA DECLARATIONS
    #define TASK1_ONE_SEC 5     // 1 sec should be 5 * 200ms period of task1
    static struct timer_task sTIMER_TC0_JIFFY, sTIMER_TC0_task1, sTIMER_TC0_task2;
    static bool volatile bTC0Task1Pending, bTC0Task2Pending;

    //  LOCAL DEFINES DECLARATIONS
    #define STARTUP_TIMERS_MSG    (MSG_TKN_INFO"System timers init: ")
    #define MAX_HASH_ASIC_TEMPERATURE 85     // should be 90 in deg C; asic temperature we can tolerate
    #define TASK1_ONE_SEC 5     // 1 sec should be 5 * 200ms period of task1
*/
//#endif    // #if (HW_ATSAMG55_XP_BOARD != HARDWARE_PLATFORM)

static S_FAN_STATUS_T sFanStatus[2];

#ifdef ENABLE_EMC_TEST_FUNCTIONS
#define EMC_TEST_IDLE 0
#define EMC_TEST_START 1
#define EMC_TEST_RUNNING 2
#define EMC_TEST_STOP 3
#define EMC_SAFE_TEMPERATURE (MAX_HASH_ASIC_TEMPERATURE - 10) // in deg C; asic temperature we can tolerate during EMC test
static int iEMCTestState = EMC_TEST_IDLE; // temporary var for control of EMC test task
#endif // #ifdef ENABLE_EMC_TEST_FUNCTIONS

/***********************************/
/***                             ***/
/***     THE CODE BEGINS HERE    ***/
/***                             ***/
/***********************************/

#ifdef ENABLE_EMC_TEST_FUNCTIONS
/** ************************************************************
 *  \brief Accessor function to enable EMC test function
 */
void SetEMCTest(void)
{
    if (EMC_TEST_IDLE == iEMCTestState) {
        iEMCTestState = EMC_TEST_START; // start EMC test task
    } else {
        iEMCTestState = EMC_TEST_STOP; // stop at completion
    }

} // SetEMCTest
#endif // #ifdef ENABLE_EMC_TEST_FUNCTIONS

/** ************************************************************
 *  \brief Accessor function to setup the fan status structure.
 *  At initial power on, the fans should be on at full speed.
 */
void InitFanStatus(uint8_t uiFan)
{
    if (MAX_NUM_FANS > uiFan) {
        sFanStatus[uiFan].iError = ERR_NONE;
        sFanStatus[uiFan].iSpeed = 0;
        sFanStatus[uiFan].iRPM = 0;
    }
} // InitFanStatus

/** ************************************************************
 *  \brief Accessor function for fan status/control error variable.
 */
void SetFanError(uint8_t uiFan, int iError)
{
    if (MAX_NUM_FANS > uiFan) {
        sFanStatus[uiFan].iError = iError;
    }

} // SetFanError

/** *************************************************************
 * \brief Placeholder function to test fan operation.
 * \param uiBoard sets which fam to test; 0 for front and 1 for rear
 * \return int status of board (see err_codes.h)
 */
int iTestFan(uint8_t uiFan)
{
    return (ERR_NONE);
} // iTestFan()

#if (HW_ATSAMG55_XP_BOARD == HARDWARE_PLATFORM)
/** ************************************************************
 *  \brief Handler for System Tick interrupt.
 *
 *  DO NOT CALL THIS DIRECTLY!  This is registered to an event and is executed by that event.
 *  Description: Process System Tick Event; running at 1KHz so counts are in msec.
 *  - Increments the g_ul_jiffies counter via function call.  This is called by the TC0 interrupt.
 *  - Maintains the debounce counter for the user button.
 *  - Ideally, we will shut down this timer when in the off state so as to reduce power use.  For now,
 *    we keep it running but don't do some of the tasks
 */
void cb_TIMER_TC0_task0(void)
{
    cb_Jiffies_Handler();

} // cb_TIMER_TC0_task0

/** *************************************************************
 * \brief Timer TC0 ISR callback
 *  Using timer TC0 task as periodic interrupt.  Should occur every 200msec.
 *  DO NOT CALL THIS DIRECTLY!  This is registered to an event and is executed by that event.
 */
static void cb_TIMER_TC0_task1(const struct timer_task* const timer_task)
{
    bTC0Task1Pending = true; // set a flag to notify main loop

} // cb_TIMER_TC0_task1

/** *************************************************************
 * \brief Timer TC0 ISR callback for 2nd task (5 sec)
 *
 *  DO NOT CALL THIS DIRECTLY!  This is registered to an event and is executed by that event.
 */
static void cb_TIMER_TC0_task2(const struct timer_task* const timer_task)
{
    bTC0Task2Pending = true; // set a flag to notify main loop
} // cb_TIMER_TC0_task2

/** *************************************************************
 * \brief Timer TC0 Initialization and Callbacks
 *
 */
static void StartupTimerTasks(void)
{
#define TASK1_MS 200 // (msec) periodic task (for 1KHz timer base)
#define TASK2_MS (5 * SYSTEM_BASE_TICK_PER_SEC) // (msec) 5 sec tasks

    // Jiffy timer is used at 1KHz as system tick and to time things like button presses
    sTIMER_TC0_JIFFY.interval = 1; // in ms (assuming 1KHz timer base)
    sTIMER_TC0_JIFFY.cb = (timer_cb_t)cb_TIMER_TC0_task0;
    sTIMER_TC0_JIFFY.mode = TIMER_TASK_REPEAT;
    JiffiesInit();

    sTIMER_TC0_task1.interval = TASK1_MS; // in ms (assuming 1KHz timer base)
    sTIMER_TC0_task1.cb = cb_TIMER_TC0_task1;
    sTIMER_TC0_task1.mode = TIMER_TASK_REPEAT;
    sTIMER_TC0_task2.interval = TASK2_MS; // in ms (assuming 1KHz timer base)
    sTIMER_TC0_task2.cb = cb_TIMER_TC0_task2;
    sTIMER_TC0_task2.mode = TIMER_TASK_REPEAT;

    timer_add_task(&TASK_TMR, &sTIMER_TC0_JIFFY);
    timer_add_task(&TASK_TMR, &sTIMER_TC0_task1);
    timer_add_task(&TASK_TMR, &sTIMER_TC0_task2);
    timer_start(&TASK_TMR);

} // StartupTimerTasks()

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler_Msg(void)
{
    uint8_t uiIRQNo;
    // read the IRQ in service for information on why we got here
    uiIRQNo = _irq_get_current();
    if (0 == uiIRQNo) {
        gpio_toggle_pin_level(LED0);
        delay_ms(10);
    }

    CONSOLE_OUTPUT_IMMEDIATE("/r/n-E- Dummy Handler"); // actually can't send this if IRQs are faulted
    delay_ms(500);
    while (1) {
        // quick flashing as indicator
        delay_ms(50);
        gpio_toggle_pin_level(LED0);
    }
} // Dummy_Handler_Msg
#endif // #if (HW_ATSAMG55_XP_BOARD == HARDWARE_PLATFORM)
