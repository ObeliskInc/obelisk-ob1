/**
 * \file Usermain.c
 *
 * \brief User Main
 * \date STARTED: 3/19/2018
 *
 * \mainpage Obelisk Test Hash Board SPI - Documentation Notes
 *
 * \section Legal
 * **Copyright Notice:**
 * Copyright (c) 2018 All rights reserved.
 *
 * **Proprietary Notice:**
 *       This document contains proprietary information and neither the document
 *       nor said proprietary information shall be published, reproduced, copied,
 *       disclosed or used for any purpose other than the consideration of this
 *       document without the expressed written permission of a duly authorized
 *       representative of said Company.
 *
 * **Disclaimer Notice:**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING,
 * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ENGINEERING OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * \section Purpose
 * Written for the SAMG55XP board to provide a means of exercising hash boards until the real controller
 * board hardware is functioning.
 *
 * Primary function is to support testing the hardware devices and the AC coupled SPI interface to the
 * CSS Blake2B ASIC. To do this we service various tasks including:
 * -# Accept simple character input from console and perform tasks
 * -# Transmit/receive data on a SPI bus interface
 *
 * \section Description
 * Basic software structure is a main loop that continuously runs and executes tasks. Occasionally
 * interrupts occur that either set signal flags to run the tasks from the main loop or perform
 * tasks on their own (if they are short).
 *
 * The ATSAMG55XP is being used for testing and is not expected to be the system processor.
 * Therefore, firmware development and documentation may be casually implemented in interests of speed of development.
 *
 * Processor peripheral usage summary (use Atmel START utility for details):
 * WHEN USING ATSAMG55 XPlained EVAL BOARD:
 * - FLEXCOM 5 as SPI: on XPlained connects to EXT1 and 3; EXT3 used for test interface.
 * - FLEXCOM 4 as I2C: on XPlained connects to EXT3
 * - FLEXCOM 7 as UART: used for debug console (embedded debug port)
 * - TC0: 1KHz system timer for sub-timer generation.
 *
 * \section Requirements
 * **Expected target devices:**
 * - Processor is Microchip SAMA5D27; chosen for Linux support and low cost
 *
 * \section Usage under development
 * Initial development done with SAMG55XP evaluation board.
 *
 * - Initial test processor is Atmel/Microchip ATSAMG55; chosen for convenience
 * **Development environment:**
 * ATSAMG55 under AS7 (build 7.0.1417)
 * TechEn (TAR) project initially constructed using Atmel ASF4/START (start.atmel.com) for the ATSAMG55 XPlained board (SAMG55XP).
 * Sadly, this build of AS7 has a number of problems.
 * - It sometimes (often?) deletes the ApplicationFiles folder and the Device_Startup folder when reconfiguring the project.
 *   Workaround for this is to remove these folders from the project prior to reconfiguring and then including them back.
 * - Above two issues have been logged to Microchip for fix in future versions.
 * - Autogenerated code gives duplicate IRQ handlers for Flexcom peripherals. TWI, SPI and UART files need to be edited and ensure
 *   that only the relevant IRQ handler functions are enabled.
 * -- In hpl_twi.c, find and comment out FLEXCOM5_Handler() and FLEXCOM7_Handler().
 * -- In hpl_usartc, find and comment out FLEXCOM4_Handler() and FLEXCOM5_Handler().
 * -- In hpl_spi.c, find and comment out FLEXCOM4_Handler() and FLEXCOM7_Handler().
 * - Autogenerated code in hpl_twi.c has bug in the I2C transfer function name _i2c_m_async_transfer().  Proper code is duplicated in
 * TWI_Support.c as compiled out code.  Cut and paste this into hpl_twi.c. Support case is logged with Microchip to fix this issue.
 *
 * -# Use AtmelStudio to open project.
 * -# Build the program and download it inside the evaluation board.
 * -# On the computer, open and configure a terminal application
 *    (e.g. RealTerm, TeraTerm, Putty, etc.) with these settings:
 *   - 115200 bauds
 *   - 8 bits of data
 *   - No parity
 *   - 1 stop bit
 *   - No flow control
 * -# Start the application.
 * -# The LED(s) should start blinking on the evaluation board.
 * -# When compiled with keyword DEBUG_CONSOLE defined (in Console.h), it should send ASCII text strings to the
 *    UART for test purposes.  In the terminal window, a brief start up message should appear.
 *
 * \section Main History
 * PRERELEASE/DEVELOPMENT*
 * - 20180319 Rev 0.01 Started; using AS7 (build 7.0.1417); Running on ATSAMG55 XP eval board
 * - 20180702 Rev 0.-- Porting into SAMA5D27 SOM
 *
 * \section BUILD NOTES
 * Platform is controlled by complile switches located in usermain.h.
 * - Devel operation HARDWARE_PLATFORM ==  HW_ATSAMG55_XP_BOARD; runs on the SAMG55 evaluation board
 * - Normal operation HARDWARE_PLATFORM ==  HW_SAMA5D27_SOM; runs on the expected system
 *
 * \section Known Issues
 *  - See #TODO items throughout the code.
 *  - See defined DEBUG_CONSOLE in Console.h; set to true to enable output to a uart console (serial port) for debug purposes.
 *
 * \section "Style Summary"
 *  Comments with keywords are noted for use of Doxygen mainpage.
 *  - using  Hungarian systems notation but shouldn't overdo it;
 *       - vars are prefixed by type;
 *          - b - bool, ui - unsigned int, l - long, z - zero terminate string,
 *            s - struct, h - handle, x - index, etc
 *      - arrays add 'a' after prefix; e.g. ba prefix is bool array, ca is char array, sa is struct array, ...
 *      - ptrs are prefixed by 'p'; e.g. pz is a ptr to zero-terminated string
 *      - functions are prefixed by return type
 *          - use cb_ prefix for callbacks
 *          - use isr_ prefix for simple interrupt service
 *          - use io_ for io descriptors (typically a structure)
 *      - global scope variables (strongly discouraged!) should begin with g_ prefix
 * - using CamelCase for var and function names for custom application code.
 *      - where abbreviations and mnemonics are used, put an '_' to separate for readability as needed.
 *      - where function and variable names are defined by the vendor tools; leave them as is
 *
 */

/***   INCLUDE FILES               ***/

//#if (HW_ATSAMG55_XP_BOARD != HARDWARE_PLATFORM)
// Initialization/declarations for SAMA5D27

// General or std-c files
#include <unistd.h>

// Project specific include files
#include "Usermain.h"
#include "spi.h"
#include "SPI_Support.h"
#include "TWI_Support.h"
#include "Ob1Hashboard.h"
#include "gpio_bsp.h"
#include "MCP9903_hal.h"
#include "MiscSupport.h"
#include "MCP23S17_hal.h"
#include "CSS_SC1_hal.h"
#include "CSS_DCR1_hal.h"
#include "Console.h"
#include "ads1015.h"
#include "EMCTest.h"
#include "Ob1Utils.h"

//=================================================================================================
// CONTROL LOOP CONFIG/VARS
//
char outBuf[1024];

// CONTROL LOOP CONFIG
#define CONTROL_LOOP_SUPER_HIGH_TEMP 122
#define CONTROL_LOOP_HIGH_TEMP 120
#define CONTROL_LOOP_LOW_TEMP 110

#define MIN_BIAS -5
#define NO_BIAS 0
#define MAX_BIAS 5

// Start at /4, MAX_BIAS
// If over HIGH_TEMP, drop by one bias unit each tenth of a second
// If under LOW_TEMP, increment by one bias unit
// Add visible printouts showing the current voltage and bias
// /4+1
// Add code to wrap around the bias: decrementBias(ControlLoopState),
// increment_bias(ControlLoopState)

ControlLoopState controlLoopState[MAX_NUMBER_OF_HASH_BOARDS] = {
    { 0, 0, 0, 2, NO_BIAS, 0, true },
    { 1, 0, 0, 2, NO_BIAS, 0, true },
    { 2, 0, 0, 2, NO_BIAS, 0, true },
};

// // Functions for adding/subtracting bias and dividers
// void incrementDivider(ControlLoopState* clState)
// {
//     switch (clState->currDivider) {
//     case 1:
//     case 2:
//     case 4:
//         clState->currDivider *= 2;
//         break;
//     default:
//         // 8 or any other value means no change
//         break;
//     }
//     clState->lastChangeUp = true;
// }

// void decrementDivider(ControlLoopState* clState)
// {
//     switch (clState->currDivider) {
//     case 2:
//     case 4:
//     case 8:
//         clState->currDivider /= 2;
//         break;
//     default:
//         // 1 or any other value means no change
//         break;
//     }
//     clState->lastChangeUp = false;
// }

// void incrementBias(ControlLoopState* clState)
// {
//     if (clState->currBias == MAX_BIAS) {
//         int currDivider = clState->currDivider;
//         decrementDivider(clState);
//         // Prevent overflow
//         if (currDivider > 1) {
//             clState->currBias = MIN_BIAS;
//         }
//     } else {
//         clState->currBias += 1;
//     }
//     clState->lastChangeUp = true;
// }

// void decrementBias(ControlLoopState* clState)
// {
//     if (clState->currBias == MIN_BIAS) {
//         int currentDivider = clState->currDivider;
//         incrementDivider(clState);
//         // Prevent underflow of the bias
//         if (currentDivider < 8) {
//             clState->currBias = MAX_BIAS;
//         }
//     } else {
//         clState->currBias -= 1;
//     }
//     clState->lastChangeUp = false;
// }

// void formatControlLoopState(char* buffer, ControlLoopState* clState)
// {
//     (void)sprintf(buffer, "HB%u: %uC %c /%u%s%d bias",
//         clState->boardId + 1,
//         clState->lastTemp,
//         clState->lastChangeUp ? '^' : 'v',
//         clState->currDivider,
//         clState->currBias < 0 ? "" : "+",
//         clState->currBias);
// }

// void formatDividerAndBias(char* buffer, ControlLoopState* clState)
// {
//     (void)sprintf(buffer, "/%u%s%d",
//         clState->currDivider,
//         clState->currBias < 0 ? "" : "+",
//         clState->currBias);
// }

//=================================================================================================

//   LOCAL DEFINITIONS
#define STARTUP_TIMERS_MSG (MSG_TKN_INFO "System timers init: ")
#define MAX_HASH_ASIC_TEMPERATURE 125 // should be 90 in deg C; asic temperature we can tolerate

//   LOCAL FUNCTION PROTOTYPES
#ifdef ENABLE_EMC_TEST_FUNCTIONS
//static void SetEMCTest(void);
#endif // #ifdef ENABLE_EMC_TEST_FUNCTIONS

//#else
/*
    // Initialization/declarations for ATSAMG55
    
    // #include "hal_spi_m_async.h"
    #include "ApplicationFiles\Usermain.h"
    #include "ApplicationFiles\Support\Jiffies\SysTickJiffies.h" // system tick support
    #include "ApplicationFiles\Support\Console\Console.h"        // development console/uart support
    #include "ApplicationFiles\BSP\MCP9903\MCP9903_hal.h"
    #include "ApplicationFiles\BSP\SPI_Support\SPI_Support.h"
    #include "ApplicationFiles\BSP\TWI_Support\TWI_Support.h"
    #include "ApplicationFiles\BSP\HashBoard\Ob1Hashboard.h"
    #include "ApplicationFiles\BSP\SC1ASIC\CSS_SC1_hal.h"
    #include "ApplicationFiles\BSP\MCP23S17\MCP23S17_hal.h"
    //  LOCAL FUNCTION PROTOTYPES
    static void cb_TIMER_TC0_task1(const struct timer_task *const timer_task);
    static void cb_TIMER_TC0_task2(const struct timer_task *const timer_task);
    static void StartupTimerTasks(void);
    
    //   LOCAL DATA DECLARATIONS
    #define TASK1_ONE_SEC 5     // 1 sec should be 5 * 200ms period of task1
    static struct timer_task sTIMER_TC0_JIFFY, sTIMER_TC0_task1, sTIMER_TC0_task2;
    static bool volatile bTC0Task1Pending, bTC0Task2Pending;

    //  LOCAL DEFINES DECLARATIONS
    #define STARTUP_TIMERS_MSG    (MSG_TKN_INFO"System timers init: ")
    #define MAX_HASH_ASIC_TEMPERATURE 85     // should be 90 in deg C; asic temperature we can tolerate
    #define TASK1_ONE_SEC 5     // 1 sec should be 5 * 200ms period of task1
*/
//#endif    // #if (HW_ATSAMG55_XP_BOARD != HARDWARE_PLATFORM)

static S_FAN_STATUS_T sFanStatus[2];

#ifdef ENABLE_EMC_TEST_FUNCTIONS
#define EMC_TEST_IDLE 0
#define EMC_TEST_START 1
#define EMC_TEST_RUNNING 2
#define EMC_TEST_STOP 3
#define EMC_SAFE_TEMPERATURE (MAX_HASH_ASIC_TEMPERATURE - 10) // in deg C; asic temperature we can tolerate during EMC test
static int iEMCTestState = EMC_TEST_IDLE; // temporary var for control of EMC test task
#endif // #ifdef ENABLE_EMC_TEST_FUNCTIONS

/***********************************/
/***                             ***/
/***     THE CODE BEGINS HERE    ***/
/***                             ***/
/***********************************/

#ifdef ENABLE_EMC_TEST_FUNCTIONS
/** ************************************************************
 *  \brief Accessor function to enable EMC test function
 */
void SetEMCTest(void)
{
    if (EMC_TEST_IDLE == iEMCTestState) {
        iEMCTestState = EMC_TEST_START; // start EMC test task
    } else {
        iEMCTestState = EMC_TEST_STOP; // stop at completion
    }

} // SetEMCTest
#endif // #ifdef ENABLE_EMC_TEST_FUNCTIONS

/** ************************************************************
 *  \brief Accessor function to setup the fan status structure.
 *  At initial power on, the fans should be on at full speed.
 */
void InitFanStatus(uint8_t uiFan)
{
    if (MAX_NUM_FANS > uiFan) {
        sFanStatus[uiFan].iError = ERR_NONE;
        sFanStatus[uiFan].iSpeed = 0;
        sFanStatus[uiFan].iRPM = 0;
    }
} // InitFanStatus

/** ************************************************************
 *  \brief Accessor function for fan status/control error variable.
 */
void SetFanError(uint8_t uiFan, int iError)
{
    if (MAX_NUM_FANS > uiFan) {
        sFanStatus[uiFan].iError = iError;
    }

} // SetFanError

/** *************************************************************
 * \brief Placeholder function to test fan operation.
 * \param uiBoard sets which fam to test; 0 for front and 1 for rear
 * \return int status of board (see err_codes.h)
 */
int iTestFan(uint8_t uiFan)
{
    return (ERR_NONE);
} // iTestFan()

#if (HW_ATSAMG55_XP_BOARD == HARDWARE_PLATFORM)
/** ************************************************************
 *  \brief Handler for System Tick interrupt.
 *
 *  DO NOT CALL THIS DIRECTLY!  This is registered to an event and is executed by that event.
 *  Description: Process System Tick Event; running at 1KHz so counts are in msec.
 *  - Increments the g_ul_jiffies counter via function call.  This is called by the TC0 interrupt.
 *  - Maintains the debounce counter for the user button.
 *  - Ideally, we will shut down this timer when in the off state so as to reduce power use.  For now,
 *    we keep it running but don't do some of the tasks
 */
void cb_TIMER_TC0_task0(void)
{
    cb_Jiffies_Handler();

} // cb_TIMER_TC0_task0

/** *************************************************************
 * \brief Timer TC0 ISR callback
 *  Using timer TC0 task as periodic interrupt.  Should occur every 200msec.
 *  DO NOT CALL THIS DIRECTLY!  This is registered to an event and is executed by that event.
 */
static void cb_TIMER_TC0_task1(const struct timer_task* const timer_task)
{
    bTC0Task1Pending = true; // set a flag to notify main loop

} // cb_TIMER_TC0_task1

/** *************************************************************
 * \brief Timer TC0 ISR callback for 2nd task (5 sec)
 *
 *  DO NOT CALL THIS DIRECTLY!  This is registered to an event and is executed by that event.
 */
static void cb_TIMER_TC0_task2(const struct timer_task* const timer_task)
{
    bTC0Task2Pending = true; // set a flag to notify main loop
} // cb_TIMER_TC0_task2

/** *************************************************************
 * \brief Timer TC0 Initialization and Callbacks
 *
 */
static void StartupTimerTasks(void)
{
#define TASK1_MS 200 // (msec) periodic task (for 1KHz timer base)
#define TASK2_MS (5 * SYSTEM_BASE_TICK_PER_SEC) // (msec) 5 sec tasks

    // Jiffy timer is used at 1KHz as system tick and to time things like button presses
    sTIMER_TC0_JIFFY.interval = 1; // in ms (assuming 1KHz timer base)
    sTIMER_TC0_JIFFY.cb = (timer_cb_t)cb_TIMER_TC0_task0;
    sTIMER_TC0_JIFFY.mode = TIMER_TASK_REPEAT;
    JiffiesInit();

    sTIMER_TC0_task1.interval = TASK1_MS; // in ms (assuming 1KHz timer base)
    sTIMER_TC0_task1.cb = cb_TIMER_TC0_task1;
    sTIMER_TC0_task1.mode = TIMER_TASK_REPEAT;
    sTIMER_TC0_task2.interval = TASK2_MS; // in ms (assuming 1KHz timer base)
    sTIMER_TC0_task2.cb = cb_TIMER_TC0_task2;
    sTIMER_TC0_task2.mode = TIMER_TASK_REPEAT;

    timer_add_task(&TASK_TMR, &sTIMER_TC0_JIFFY);
    timer_add_task(&TASK_TMR, &sTIMER_TC0_task1);
    timer_add_task(&TASK_TMR, &sTIMER_TC0_task2);
    timer_start(&TASK_TMR);

} // StartupTimerTasks()

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler_Msg(void)
{
    uint8_t uiIRQNo;
    // read the IRQ in service for information on why we got here
    uiIRQNo = _irq_get_current();
    if (0 == uiIRQNo) {
        gpio_toggle_pin_level(LED0);
        delay_ms(10);
    }

    CONSOLE_OUTPUT_IMMEDIATE("/r/n-E- Dummy Handler"); // actually can't send this if IRQs are faulted
    delay_ms(500);
    while (1) {
        // quick flashing as indicator
        delay_ms(50);
        gpio_toggle_pin_level(LED0);
    }
} // Dummy_Handler_Msg
#endif // #if (HW_ATSAMG55_XP_BOARD == HARDWARE_PLATFORM)

/***********************************/
/***                             ***/
/***     MAIN LOOP               ***/
/***                             ***/
/***********************************/
/** *************************************************************
 *  \brief Main loop and initialization
 */
int usermain(void)
{
    static uint8_t tempPotValue = 10;
    int iResult;
    bool bReportStatus = false;
    uint8_t uiBoard;
    S_MCP9903_DATA_T* psaTemperatureData[MAX_NUMBER_OF_HASH_BOARDS]; // Most recent conversion data
    S_MCP9903_DATA_T saInvalidBoardTemperatures;
    int ixI;
    bool overTempFlag = false;
    int iPrintCounter = 0;

#ifdef ENABLE_EMC_TEST_FUNCTIONS
    uint32_t ulEMCTestCounter = 0;
    bool bEMCOverTemperatureFlag;
#endif // #ifdef ENABLE_EMC_TEST_FUNCTIONS

// ***** ATSAMG55 STARTUP *****
#if (HW_ATSAMG55_XP_BOARD == HARDWARE_PLATFORM)
#define STARTUP_DELAY_MS 100
    uint32_t ulTestJiffies1, ulTestJiffies2;

    /* Initializes (ATSAMG55) MCU, drivers and middleware */
    atmel_start_init();
#ifdef DEBUG_CONSOLE
    // Get debug console started early so we can report system status.
    DebugConsoleInitialize();
#endif
    // Start up timers that we use for tasks and for time determination
    // Should be using a 1KHz system tick as base time.
    StartupTimerTasks(); // setup periodic timer tasks

    // Run a timer test to verify the jiffies count is as expected.
    ulTestJiffies1 = g_ul_jiffies;
    delay_ms(STARTUP_DELAY_MS); // stabilize time (brief delay for us to check the timer operation)
    ulTestJiffies2 = g_ul_jiffies;
#ifdef DEBUG_CONSOLE
    CONSOLE_OUTPUT_IMMEDIATE(STARTUP_TIMERS_MSG);
    if ((STARTUP_DELAY_MS - 2) < (unsigned int)(ulTestJiffies2 - ulTestJiffies1) && (STARTUP_DELAY_MS + 2) > (unsigned int)(ulTestJiffies2 - ulTestJiffies1)) {
        (void)snprintf(caStringVar, CONSOLE_LINE_SIZE, "passed\r\n");
    } else {
        (void)snprintf(caStringVar, CONSOLE_LINE_SIZE, "FAILED (expected %u; found %u)\r\n", STARTUP_DELAY_MS, (unsigned int)(ulTestJiffies2 - ulTestJiffies1));
    }
    CONSOLE_OUTPUT_IMMEDIATE(caStringVar);
#endif // #ifdef DEBUG_CONSOLE

    // Control board setup and POST functions
    iResult = iTWIPortInit(NUM_TWI_PORTS); // initialize any TWI ports for hashing board comms
    if (ERR_NONE == iResult) {
        SPI5_Startup(); // initialize the SPI for hashing board comms
        iResult = iHashBoardInit(MAX_NUMBER_OF_HASH_BOARDS); // detect and initialize hashing boards
        if (ERR_NONE == iResult) {
            (void)snprintf(caStringVar, CONSOLE_LINE_SIZE, "\r\nHashing boards initialized successfully\r\n");
        } else {
            (void)snprintf(caStringVar, CONSOLE_LINE_SIZE, "\r\n Hashing boards failed to initialize\r\n");
        }
        CONSOLE_OUTPUT_IMMEDIATE(caStringVar);
    }
#endif // #if (HW_ATSAMG55_XP_BOARD == HARDWARE_PLATFORM)
    // ***** ATSAMG55 STARTUP *****

#if (HW_ATSAMG55_XP_BOARD != HARDWARE_PLATFORM)
    start_dsTimer();

    printf("\n||||| START NEW MINER |||||\n\n");

    iResult = gpio_init();
    if (ERR_NONE != iResult) {
#ifdef HB_FUNC_TEST
        set_HBFuncTestErrorFlag(true); //There was an error - flash red LED
#endif //HB_FUNC_TEST
        (void)snprintf(caStringVar, CONSOLE_LINE_SIZE, "-E- gpio_init() FAIL: returns %d\n", iResult);
        CONSOLE_OUTPUT_IMMEDIATE(caStringVar);
    }

    led_green_on();
    led_red_off();

    // Control board setup and POST functions
    iResult = iTWIPortInit(NUM_TWI_PORTS); // initialize any TWI ports for hashing board comms
    printf("-E- iTWIPortInit isn't needed?\n");
    if (ERR_NONE != iResult) {
        printf("-E- iTWIPortInit(%d) FAIL: returns: %d\n", NUM_TWI_PORTS, iResult);
    }

    iResult = spi_setup();
    if (ERR_NONE != iResult) {
#ifdef HB_FUNC_TEST
        set_HBFuncTestErrorFlag(true); //There was an error - flash red LED
#endif //HB_FUNC_TEST
        (void)snprintf(caStringVar, CONSOLE_LINE_SIZE, "-E- spi_setup() FAIL: returns %d\n", iResult);
        CONSOLE_OUTPUT_IMMEDIATE(caStringVar);
    } else {
        HBSetSpiSelects(MAX_NUMBER_OF_HASH_BOARDS, true);
        iResult = iHashBoardInit(MAX_NUMBER_OF_HASH_BOARDS); // detect and initialize hashing boards
        if (ERR_NONE != iResult) {
#ifdef HB_FUNC_TEST
            set_HBFuncTestErrorFlag(true); //There was an error - flash red LED
#endif //HB_FUNC_TEST
            (void)snprintf(caStringVar, CONSOLE_LINE_SIZE, "-E- iHashBoardInit() FAIL: returns %d\n", iResult);
            CONSOLE_OUTPUT_IMMEDIATE(caStringVar);
        }
    }
#endif // #if (HW_ATSAMG55_XP_BOARD != HARDWARE_PLATFORM)

    // Get ptrs to the hashboard temperature data for monitoring; Do once before the main loop.
    // These don't change so we can refer to them as needed in the main loop.
    saInvalidBoardTemperatures.iaDataRawInt[TEMP_INT] = 0;
    saInvalidBoardTemperatures.iaDataRawInt[TEMP_ASIC] = 0;
    saInvalidBoardTemperatures.iaDataRawInt[TEMP_PS] = 0;
    for (ixI = 0; ixI < MAX_NUMBER_OF_HASH_BOARDS; ixI++) {
        uiBoard = (uint8_t)ixI;
        if (ERR_NONE != iIsBoardValid(uiBoard, true)) {
            psaTemperatureData[uiBoard] = &saInvalidBoardTemperatures;
        } else {
            iResult = iGetTemperaturesDataPtr(uiBoard, &psaTemperatureData[uiBoard]);
            if ((ERR_NONE == iResult) && (NULL == psaTemperatureData[uiBoard])) {
                (void)snprintf(caStringVar, CONSOLE_LINE_SIZE, "\r\n ERROR! NULL ptr returned\r\n");
                CONSOLE_OUTPUT_IMMEDIATE(caStringVar);
                psaTemperatureData[uiBoard] = &saInvalidBoardTemperatures;
            }

#ifdef HB_FUNC_TEST
            else if (ERR_NONE) {
                if (((10 > psaTemperatureData[uiBoard]->iaDataRawInt[TEMP_INT]) || (40 < psaTemperatureData[uiBoard]->iaDataRawInt[TEMP_INT]))
                    || ((10 > psaTemperatureData[uiBoard]->iaDataRawInt[TEMP_ASIC]) || (40 < psaTemperatureData[uiBoard]->iaDataRawInt[TEMP_ASIC]))
                    || ((10 > psaTemperatureData[uiBoard]->iaDataRawInt[TEMP_PS]) || (40 < psaTemperatureData[uiBoard]->iaDataRawInt[TEMP_PS]))) {
                    (void)snprintf(caStringVar, CONSOLE_LINE_SIZE, "-E- Temperature out of range\n");
                    CONSOLE_OUTPUT_IMMEDIATE(caStringVar);
                    set_HBFuncTestErrorFlag(true); //There was an error - flash red LED
                }
            }
#endif //HB_FUNC_TEST
        } // if (ERR_NONE != iIsBoardValid(uiBoard,true))
    } // for

#if (HW_ATSAMG55_XP_BOARD != HARDWARE_PLATFORM)

    // create_timer(100000000, OneSecTmr); // TWEAK - 10 times per second
    // create_timer(1000000000, OneSecTmr); // ONE SECOND
    //create_timer(5000000000, FiveSecTmr);

#ifdef ENABLE_EMC_TEST_FUNCTIONS
    SetEMCTest();
#endif // #ifdef ENABLE_EMC_TEST_FUNCTIONS

#ifdef HB_FUNC_TEST
    //TODO: Check temp values

    // End of functional testing
    set_HBFuncTestFlag(false);

    CONSOLE_OUTPUT_IMMEDIATE("==================================\n");
    CONSOLE_OUTPUT_IMMEDIATE("Hashboard functional test complete\n");
    CONSOLE_OUTPUT_IMMEDIATE("==================================\n\n\n");

    while (1) {
        // Just sit here so the LED toggles keep working
        usleep(1000);
    }

#endif //HB_FUNC_TEST
    printf("\n||||| START OF FOREVER |||||\n");
#endif // #if (HW_ATSAMG55_XP_BOARD != HARDWARE_PLATFORM)

    E_ASIC_TYPE_T boardType = eGetBoardType(0);

    while (1) { // do forever..

#if (HW_ATSAMG55_XP_BOARD == HARDWARE_PLATFORM)
#ifdef DEBUG_CONSOLE
        (void)iConsoleInHandler(); // Check for input at console
        (void)iConsoleOutHandler(); // Send output to console uart
#endif // #ifdef DEBUG_CONSOLE \
    // Periodic (timer task1 based) tasks; done approx 5 times per second
        if (true == bTC0Task1Pending) { // Periodic task 1:
            gpio_toggle_pin_level(LED0);
            bTC0Task1Pending = false;

        } else if (true == bTC0Task2Pending) { // don't do both Task1 and Task2 (defer Task2 if needed)
            bReportStatus = true;
            bTC0Task2Pending = false;
            // end of periodic 5 sec tasks

        } // if (true == bTC0Task1Pending)

#endif // #if (HW_ATSAMG55_XP_BOARD == HARDWARE_PLATFORM)

#if (HW_ATSAMG55_XP_BOARD != HARDWARE_PLATFORM)
#ifdef HB_FUNC_TEST
        // if (get_TenthSecFlag()) {
        //     if (false == get_HBFuncTestErrorFlag()) {
        //         led_red_toggle();
        //     }
        //     bReportStatus = false;
        // }
#else
        if (get_TenthSecFlag()) {
            // Control loop
            for (ixI = 0; ixI < MAX_NUMBER_OF_HASH_BOARDS; ixI++) {
                uiBoard = (uint8_t)ixI;
                if (ERR_NONE != iIsBoardValid(uiBoard, true)) {
                    continue;
                }

                iUpdateTempSensors(uiBoard);
                uint16_t currAsicTemp = psaTemperatureData[uiBoard]->iaDataRawInt[TEMP_ASIC];
                ControlLoopState* clBoard = &controlLoopState[uiBoard];

                // Check if the temp is too high
                if (currAsicTemp >= CONTROL_LOOP_HIGH_TEMP && clBoard->ticksSinceLastChange >= 20) {
                    decrementBias(clBoard);

                    if (E_TYPE_SC1 == boardType) {
                        iSetSC1OCRDividerAndBias(uiBoard, clBoard->currDivider, clBoard->currBias);
                    } else if (E_TYPE_DCR1 == boardType) {
                        iSetDCR1OCRDividerAndBias(uiBoard, clBoard->currDivider, clBoard->currBias);
                    }
                    formatControlLoopState(outBuf, clBoard);
                    CONSOLE_OUTPUT_IMMEDIATE("OVERTEMP: ");
                    CONSOLE_OUTPUT_IMMEDIATE(outBuf);
                    CONSOLE_OUTPUT_IMMEDIATE("\n");
                    clBoard->ticksSinceLastChange = 0;
                    clBoard->lastTempOnChange = currAsicTemp;
                }

                if (currAsicTemp >= CONTROL_LOOP_SUPER_HIGH_TEMP && clBoard->ticksSinceLastChange >= 10) {
                    decrementBias(clBoard);

                    if (E_TYPE_SC1 == boardType) {
                        iSetSC1OCRDividerAndBias(uiBoard, clBoard->currDivider, clBoard->currBias);
                    } else if (E_TYPE_DCR1 == boardType) {
                        iSetDCR1OCRDividerAndBias(uiBoard, clBoard->currDivider, clBoard->currBias);
                    }
                    formatControlLoopState(outBuf, clBoard);
                    CONSOLE_OUTPUT_IMMEDIATE("OVERTEMP SUPER: ");
                    CONSOLE_OUTPUT_IMMEDIATE(outBuf);
                    CONSOLE_OUTPUT_IMMEDIATE("\n");
                    clBoard->ticksSinceLastChange = 0;
                    clBoard->lastTempOnChange = currAsicTemp;
                }

                // Check if the temp is too low or if temp did not increase since the last time
                if (clBoard->ticksSinceLastChange >= 100) {
                    if (currAsicTemp <= CONTROL_LOOP_LOW_TEMP && (int)currAsicTemp - (int)clBoard->lastTempOnChange <= 2) {
                        // Bump up the voltage bias (and thus the clockrate)
                        incrementBias(clBoard);
                        if (E_TYPE_SC1 == boardType) {
                            iSetSC1OCRDividerAndBias(uiBoard, clBoard->currDivider, clBoard->currBias);
                        } else if (E_TYPE_DCR1 == boardType) {
                            iSetDCR1OCRDividerAndBias(uiBoard, clBoard->currDivider, clBoard->currBias);
                        }
                        formatControlLoopState(outBuf, clBoard);
                        CONSOLE_OUTPUT_IMMEDIATE("Undertemp: ");
                        CONSOLE_OUTPUT_IMMEDIATE(outBuf);
                        CONSOLE_OUTPUT_IMMEDIATE("\n");
                        clBoard->lastTempOnChange = currAsicTemp;
                    } else {
                        clBoard->lastTempOnChange = currAsicTemp;
                    }
                    clBoard->ticksSinceLastChange = 0;
                } else {
                    // No change
                    clBoard->ticksSinceLastChange++;
                }
                clBoard->lastTemp = currAsicTemp;
            }

            iPrintCounter++;
            if (iPrintCounter == 10) {
                //printf("\n_____START of 1 Sec Tasks_____\n");

                // Table header
                CONSOLE_OUTPUT_IMMEDIATE("                    ");
                for (ixI = 0; ixI < MAX_NUMBER_OF_HASH_BOARDS; ixI++) {
                    sprintf(outBuf, "            HB%u", ixI + 1);
                    CONSOLE_OUTPUT_IMMEDIATE(outBuf);
                }
                CONSOLE_OUTPUT_IMMEDIATE("\n=================================================================\n");

                led_green_toggle();
                gpio_toggle_pin_level(CONTROLLER_GREEN_LED);
                iPrintCounter = 0;

                // Temperature Row
                sprintf(outBuf, "%-20s", "Last Temp (C)");
                CONSOLE_OUTPUT_IMMEDIATE(outBuf);
                for (ixI = 0; ixI < MAX_NUMBER_OF_HASH_BOARDS; ixI++) {
                    ControlLoopState* clBoard = &controlLoopState[ixI];
                    sprintf(outBuf, "%15.f", clBoard->lastTemp);
                    CONSOLE_OUTPUT_IMMEDIATE(outBuf);
                }
                CONSOLE_OUTPUT_IMMEDIATE("\n");

                // Direction of last change
                sprintf(outBuf, "%-20s", "Last Change Dir.");
                CONSOLE_OUTPUT_IMMEDIATE(outBuf);
                for (ixI = 0; ixI < MAX_NUMBER_OF_HASH_BOARDS; ixI++) {
                    ControlLoopState* clBoard = &controlLoopState[ixI];
                    sprintf(outBuf, "%15s", clBoard->lastChangeUp ? "up" : "down");
                    CONSOLE_OUTPUT_IMMEDIATE(outBuf);
                }
                CONSOLE_OUTPUT_IMMEDIATE("\n");

                // Current divider and bias
                sprintf(outBuf, "%-20s", "Divider & Bias");
                CONSOLE_OUTPUT_IMMEDIATE(outBuf);
                for (ixI = 0; ixI < MAX_NUMBER_OF_HASH_BOARDS; ixI++) {
                    char divAndBias[20];
                    ControlLoopState* clBoard = &controlLoopState[ixI];
                    formatDividerAndBias(divAndBias, clBoard);
                    sprintf(outBuf, "%15s", divAndBias);
                    CONSOLE_OUTPUT_IMMEDIATE(outBuf);
                }
                CONSOLE_OUTPUT_IMMEDIATE("\n");

                // Print hashrates
                sprintf(outBuf, "%-20s", "Hashrate (GH/s)");
                CONSOLE_OUTPUT_IMMEDIATE(outBuf);
                for (ixI = 0; ixI < MAX_NUMBER_OF_HASH_BOARDS; ixI++) {
                    HashJobInfo* jobInfo = &hashJobInfo[ixI];
                    sprintf(outBuf, "%15.2f", jobInfo->hashrateGHS);
                    CONSOLE_OUTPUT_IMMEDIATE(outBuf);
                }
                CONSOLE_OUTPUT_IMMEDIATE("\n");

                // VString values
                sprintf(outBuf, "%-20s", "VString (volts)");
                CONSOLE_OUTPUT_IMMEDIATE(outBuf);
                for (ixI = 0; ixI < MAX_NUMBER_OF_HASH_BOARDS; ixI++) {
                    S_ADS1015_DATA_T* psVMonData;
                    int iResult = iGetVMonDataPtr(ixI, &psVMonData); // get where the data is stored
                    int16_t vString = 0;

                    if (ERR_NONE == iResult) {
                        vString = psVMonData->iaDataAsmV[VMON_V15];
                    }
                    sprintf(outBuf, "%15.2f", (double)vString / 1000.0);
                    CONSOLE_OUTPUT_IMMEDIATE(outBuf);
                }
                CONSOLE_OUTPUT_IMMEDIATE("\n\n");
            }
            set_TenthSecFlag(false);
        }
#endif // else HB_FUNC_TEST

        /*
        if (get_FiveSecFlag()) {
            //printf("\n_____START of 5 Sec Tasks_____\n");
            gpio_toggle_pin_level(CONTROLLER_GREEN_LED);
            // if (true == overTempFlag) {
            //     gpio_toggle_pin_level(CONTROLLER_RED_LED);
            // }
            set_FiveSecFlag(false);

            bReportStatus = true;
        }
        */
#endif // #if (HW_ATSAMG55_XP_BOARD != HARDWARE_PLATFORM)

        // Periodic status output
        if (true == bReportStatus) { // based on task 2 (1 or maybe 5 seconds?)
#if (HW_ATSAMG55_XP_BOARD != HARDWARE_PLATFORM)
            printf("\n_____START of Periodic Tasks_____\n");
#endif // #if (HW_ATSAMG55_XP_BOARD != HARDWARE_PLATFORM) \
    // periodically we update the temperature sensor readings for installed boards
            for (ixI = 0; ixI < MAX_NUMBER_OF_HASH_BOARDS; ixI++) {
                uiBoard = (uint8_t)ixI;
                if (ERR_NONE == iIsBoardValid(uiBoard, true)) {
                    (void)iMCP9903ReportTemps(uiBoard); // update and report temps

                    if (MAX_HASH_ASIC_TEMPERATURE <= psaTemperatureData[uiBoard]->iaDataRawInt[TEMP_ASIC]) {
                        (void)snprintf(caStringVar, CONSOLE_LINE_SIZE, MSG_TKN_ERROR "HB%d overtemperature!\r\n", uiBoard + 1);
                        CONSOLE_OUTPUT(caStringVar);
                        (void)iSetHashClockEnable(uiBoard, false); // stop clocking the hash board if too hot
                        // #TODO implement recovery from this state; possibly reinitialize hash board after temperature recovers
                        //NOTE: Temp Warning
                        overTempFlag = true;
                    }
                } // if (ERR_NONE == iIsBoardValid(uiBoard,true))
            } // for
            // periodically we update the voltage readings for installed boards
            for (ixI = 0; ixI < MAX_NUMBER_OF_HASH_BOARDS; ixI++) {
                uiBoard = (uint8_t)ixI;
                if (ERR_NONE == iIsBoardValid(uiBoard, true)) {
                    (void)ReportSysVoltages(uiBoard);
                } // if (ERR_NONE == iIsBoardValid(uiBoard,true))
            } // for

            printf("     END of Periodic Tasks     \n");
            bReportStatus = false;
        } // if (true == bReportStatus)

#ifdef ENABLE_EMC_TEST_FUNCTIONS
        // EMC test process; service the state machine that submits test jobs to the boards
        if (EMC_TEST_IDLE != iEMCTestState) {
            if (EMC_TEST_START == iEMCTestState) {
                if (E_TYPE_SC1 == boardType) { // only checking first board here and assuming all are the same
                    bEMCOverTemperatureFlag = false; // Verify temperatures are safe to start the test
                    for (ixI = 0; ixI < MAX_NUMBER_OF_HASH_BOARDS; ixI++) {
                        uiBoard = (uint8_t)ixI;
                        if (ERR_NONE == iIsBoardValid(uiBoard, true)) {
                            if (EMC_SAFE_TEMPERATURE <= psaTemperatureData[uiBoard]->iaDataRawInt[TEMP_ASIC]) {
                                bEMCOverTemperatureFlag = true;
                            }
                        }
                    } // for

                    if (false == bEMCOverTemperatureFlag) {
                        ulEMCTestCounter++;
                        (void)snprintf(caStringVar, CONSOLE_LINE_SIZE, "EMC test job #%d start\r\n", ulEMCTestCounter);
                        CONSOLE_OUTPUT(caStringVar);
                        (void)iSC1EMCTestJob(EMC_TEST_STATE_START); // start of the EMC test
                        iEMCTestState++;
                    }
                } else if (E_TYPE_DCR1 == boardType) { // only checking first board here and assuming all are the same
                    bEMCOverTemperatureFlag = false; // Verify temperatures are safe to start the test
                    for (ixI = 0; ixI < MAX_NUMBER_OF_HASH_BOARDS; ixI++) {
                        uiBoard = (uint8_t)ixI;
                        if (ERR_NONE == iIsBoardValid(uiBoard, true)) {
                            if (EMC_SAFE_TEMPERATURE <= psaTemperatureData[uiBoard]->iaDataRawInt[TEMP_ASIC]) {
                                bEMCOverTemperatureFlag = true;
                            }
                        }
                    } // for

                    if (false == bEMCOverTemperatureFlag) {
                        ulEMCTestCounter++;
                        (void)snprintf(caStringVar, CONSOLE_LINE_SIZE, "EMC test job #%d start\r\n", ulEMCTestCounter);
                        CONSOLE_OUTPUT(caStringVar);
                        (void)iDCR1EMCTestJob(EMC_TEST_STATE_START); // start of the EMC test
                        iEMCTestState++;
                    }
                }
            } else {
                if (E_TYPE_SC1 == boardType) { // only checking first board here and assuming all are the same

                    iResult = iSC1EMCTestJob(EMC_TEST_STATE_RUN); // continuation of the EMC test
                    if (ERR_NONE != iResult) { // should get a 1 back if done
                        if (1 == iResult) {
                            // completed normally
                            (void)snprintf(caStringVar, CONSOLE_LINE_SIZE, "EMC test job #%d completed (%d)\r\n", ulEMCTestCounter, iResult);
                            CONSOLE_OUTPUT(caStringVar);
                            if (EMC_TEST_STOP == iEMCTestState) {
                                iEMCTestState = EMC_TEST_IDLE; // stop test
                            } else {
                                iEMCTestState = EMC_TEST_START; // restart test
                            }
                        } else { // Probably had an error
                            (void)iSC1EMCTestJob(EMC_TEST_STATE_END); // force turn off and reset of machine (don't leave asics running)
                            iEMCTestState = EMC_TEST_IDLE; // stop test
                            (void)snprintf(caStringVar, CONSOLE_LINE_SIZE, "EMC test Error (%d)\r\n", iResult);
                            CONSOLE_OUTPUT(caStringVar);
                        }
                    } // if (ERR_NONE != iResult)
                } else if (E_TYPE_DCR1 == boardType) {
                    iResult = iDCR1EMCTestJob(EMC_TEST_STATE_RUN); // continuation of the EMC test
                    if (ERR_NONE != iResult) { // should get a 1 back if done
                        if (1 == iResult) {
                            // completed normally
                            (void)snprintf(caStringVar, CONSOLE_LINE_SIZE, "EMC test job #%d completed (%d)\r\n", ulEMCTestCounter, iResult);
                            CONSOLE_OUTPUT(caStringVar);
                            if (EMC_TEST_STOP == iEMCTestState) {
                                iEMCTestState = EMC_TEST_IDLE; // stop test
                            } else {
                                iEMCTestState = EMC_TEST_START; // restart test
                            }
                        } else { // Probably had an error
                            (void)iDCR1EMCTestJob(EMC_TEST_STATE_END); // force turn off and reset of machine (don't leave asics running)
                            iEMCTestState = EMC_TEST_IDLE; // stop test
                            (void)snprintf(caStringVar, CONSOLE_LINE_SIZE, "EMC test Error (%d)\r\n", iResult);
                            CONSOLE_OUTPUT(caStringVar);
                        }
                    } // if (ERR_NONE != iResult)
                }
            } // if (EMC_TEST_START == iEnableEMCTestState)
        } // if (EMC_TEST_IDLE != iEMCTestState)
#endif // #ifdef ENABLE_EMC_TEST_FUNCTIONS

    } // while (1)

} // int usermain(void)
